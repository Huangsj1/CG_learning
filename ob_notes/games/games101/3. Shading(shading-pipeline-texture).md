> 着色：对不同物体运用不同的材质

# 一、简单着色模型——Blinn-Phong Reflectance Model

* 组成部分：
	1. 镜面反射高光（Specular highlights）
	2. 漫反射部分（Diffuse reflection）
	3. 间接光照（Ambient lighting）

## 1. 漫反射部分（Lambertian Diffuse Shading）

光源发射的能量是恒定的I，所以在每个球的表面到达的所有能量一样是I，所以球表面每个shading point的能量为 I / r^2，但是到达shading point的能量只有**部分被接收**，取决于光照和发现的夹角cosθ以及kd漫反射系数（决定明亮程度）

![[Pasted image 20230609094959.png|500]]

Ld = kd（I/r^2）max(0, n · l)

* kd 漫反射系数：反射点会**吸收**部分能量
* I / r^2：光源的能量**到达**反射点时单位面积的能量
* max( 0，n · l )：n · l 为 l 与 n的cosθ，反映了能量**接收**程度, 因为如果n与l同向，反射的能量最多，随着θ角度增大，反射能量减少
* 反射后反射点作为光源，每个球表面的能量都相同 -> **漫反射效果跟观察方向没有关系**

![[e89a14cfa62c33c8008b6e34c3b8b55.jpg|500]]

## 2. 镜面反射高光 Specular highlight

![[016e9804e01e201c6ebb8de7b7445bd.jpg]]

当夹角（偏移）增大一点的时候，反射的高光就应该**急剧减少**，就由指数p来控制

Ls = ks ( I / r^2 ) max ( 0, n · h )^p

![[360259e013af764cd5f88339b04e733.jpg|500]]

## 3. 环境光项 Ambient Term

> 光线经过环境不断反射会照到物理本来光照不到的地方

![[48f304922be804f3e5714a62e59747a.jpg]]

La = ka Ia（常量）

## 4. 完整模型

将漫反射、镜面反射高光、环境光结合起来得到整个模型

![[5dacb448b896f90e4182ef5bf215a69.jpg]]

# 二、着色频率 Shading Frequencies

![[a4b9b8861b3f6f3929dac1f7c8c1f33.jpg]]

## 1. Flat shading

将**三角形面**为单位进行着色

![[f377034762fb2ea80354bab6781390c.jpg|400]]

## 2. Gouraud shading

在每一个**顶点**上进行着色，通过插值计算，实现点与点之间颜色的平滑过渡

![[a63bc6e8e081efd9b6dbca331a8f269.jpg|400]]

通过将包含该顶点的面的法线**加权平均**来求得顶点的法线

![[50d09dab2f289aa1b184ce7dbdab62e.jpg|500]]

## 3. Phong shading

每一个**像素**着色

![[ceeebb1afd5b047ebab3fadbcb71c3e.jpg|400]]

所有像素点的法向量通过**顶点法向量插值**计算得到

![[9217990f11ab73ef6c76a6b28e6aeaa.jpg|500]]

# 三、Graphics Pipeline（Real-time Rendering）图形管线

> 从场景到二维图片经历的过程（一系列不同的操作）

1. 顶点投影到平面上
2. 点形成三角形
3. 光栅化将三角形离散在屏幕上
4. 像素着色
5. 输出图片

![[0fa57e0f55c8622734785c246d28226.jpg]]

顶点处理和像素处理是可编程的（控制着色） -> shader

# 四、Texture Mapping 纹理映射

![[88184f64348cc90e5933f5c50127f2c.jpg]]

纹理用来改变每一个像素的**属性** -> 显示出不同颜色（纹理）

三维图形的每个三角形顶点都可以对应uv坐标系下的坐标，uv坐标系的范围为\[ 0, 1 ]

## 1. Barycentric Coordinates 重心坐标（用于插值）

> 重心坐标是指在三角形上使用的一种**坐标系统**。  
> 给定三角形的三点坐标A，B，C，该平面内任意一点（x，y）都可以用这三个点坐标的线性组合表示，即 **(x, y) = αA + βB + γC**，其中 **α+β+γ=1**，且（α，β，γ）被称为该点的重心坐标（其中三角形内的点满足α, β, γ > 0）

![[27ce1fb5b6989329a53390a9fa7be61 1.jpg|300]]![[b51512ac96d56d4bfe378094f9821e1.jpg|300]]

**几何意义**：（x，y）与三角形三个顶点A，B，C构成的三个小三角形，顶点对应的小三角形的面积与三角形总面积的比值就是对应的重心坐标值

![[27ce1fb5b6989329a53390a9fa7be61.jpg]]

重心坐标的计算

![[ff6fa36b73c0a6f9e630f2a2e7cd3c2.jpg]]

三角形的重心的重心坐标为（1/3, 1/3, 1/3）

重心坐标中三角形的顶点可以代表**任何属性**：位置、纹理、坐标、颜色、深度等（用于平滑三角形）

但是重心坐标在**投影**下可能导致三个顶点的坐标**改变**，所以需要在对应时间计算对应的重心坐标来做差值

## 2. 使用重心坐标来进行纹理映射

![[07e10e2fdb26a1a47976dde5c888db9.jpg]]

```cpp
// 伪代码
// 通常来说是一个像素的中心
for each rasterized screen sample(x,y):
	// 1.用重心坐标插值计算所有点的坐标
	(u,v) = evaluate texture coordinate at (x,y) 
	// 2.根据纹理图uv上查询得到颜色
	texcolor = texture.sample(u,v);
	// 3.将颜色作为漫反射系数kd
	set sample color to texture; 
```

## 3. 纹理过小/过大导致的问题

### 1. 纹理过小

一张高分辨率的图片上运用一张纹理过小的图，会导致每个像素pixel对应的uv坐标是**小数**（如果舍入到最近的点就会导致图片**多个像素pixel都映射到同一个纹理元素texel**）

![[60447285191122fcad48bb3c26afc07.jpg]]

#### 1. Nearest 取最近的纹理元素

将对应纹理图上的点用**距离最近**的纹理元素texel来表示

#### 2. Bilinear 双线性插值

找到对应纹理图上的点的位置，取其周围四个点，**横纵坐标都进行线性插值**（过渡）：先对水平进行两次插值，再对得到的水平方向的两个点的进行竖直插值得到需要的点

![[dd3cd26893db03c1f82f42de99b43f0.jpg]]

#### 3. Bicubic 双三次插值

取周围16个点做三次插值（运算量更大，效果更好）

### 2. 纹理过大

如果纹理过大，那么**一个像素就可能包含多个纹理元素**，这多个纹理元素不同但一个像素只能显示一个纹理元素，造成**走样**

![[b3f6ad4f7bd6b620b59397cf4237bdb.jpg]]

#### 1. Supersampling 多重采样

每个像素里面再细分多个小像素来采样，效果好但性能开销过大

![[66816c0f41c644c1847c29de82441c2.jpg]]

#### 2. Mipmap

对原本的纹理图进行不断**缩小一半**的操作得到不同级别（D）的纹理图，如果查找的像素对应的纹理元素过多，就可以通过对应级别的纹理图来得到一个正方形区域内的平均值

* 只能做正方形查询

![[9490999144164be6d28e08bad4be7a6.jpg]]
![[e3894cb29b4d7865b45bcc2a6a94fca.jpg]]
所有层加起来是原本图的4/3，增多了1/3（每次边长缩小一半，面积缩小1/4）

每个像素点对应到纹理图中的点，取该像素点**周围的两个点**并映射得到他们对应的纹理图中的点，看纹理图中原本的点与周围点的**最大距离L**，以L为边长得到纹理图中的一个**正方形**，取该正方形中纹理元素的**平均值**就可以得到该像素点对应的纹理元素值（而该纹理图中正方形的平均值可以通过已经求好的**Mipmap图来查询**）

![[ee9d7ea182415441c416d1a216e062e.jpg]]

如果需要求 *非整数层*，可以通过对**相邻两层**先分别进行双线性插值得到平均值，再在这两层之间进行插值得到最终的值（**三线性插值**），就可得到下图较平滑的结果

![[0f37c8c6238e5e1807b304aaaf45b7d.jpg]]
 ![[81413b9c9b4f54fcd6b0ba207f9d599.jpg|300]] ![[2f93aeddc820240233c19e5c013629e.jpg|300]]

##### 各向异性过滤解决Overblur

> 各向异性：不同方向表现各不相同

**出现Overblur**：图像的远处出现完全模糊

由于透视的原因，一个像素映射到文理商可能是个**不规则长方形**，而mipmap采样的区域是包裹长方形的最小正方形，**采样区域增大**，造成Overblur

![[Pasted image 20230609170345.png]]

解决办法：

![[884339bf2e20243449578b916599bd4.jpg]]

1. **Ripmap**：在原本Mipmap基础上通过增加**更多层的纹理图**（其中包含**宽度/高度**压缩的）来解决Mipmap的Overblur问题（存储量增加3倍）

2. **EWA filtering**：通过**椭圆采样**，利用多次查询求平均值处理不规则区域（开销大）

## 4. 纹理的应用

### 1. 各种贴图

#### 1. 环境光贴图 Environment Map

假设光源无限远，只记录光照方向信息，将环境光记录在一张**贴图**上 —— 环境光贴图

##### 1. 球面环境映射 Spherical Environment Map

将一个**球**的球心作为世界中心，类比地球仪展开

![[58cc91c44c0fcc9c10ff413db5da84d.jpg|400]]

存在纹理的**拉伸扭曲**问题

![[ba8a1e0e03b2434db3a7648876c2e2b.jpg|500]]

##### 2. 立方体贴图 Cube Map

将环境光照记录在一个**立方体**表面上（但需要额外判断某一方向上的光照在立方体的哪一个面，计算量更大）

![[88f013742cd717da3382877cdde80bb.jpg|500]]

![[662bfded6f79cb3bf24a8c51db98704.jpg|400]]

#### 2. 记录微小几何变化

纹理不只是可以定义某点的颜色（前面用来作为kd颜色），还可以用来记录了纹理的**高度**移动等其他属性

##### 1. 凹凸贴图 Bump Mapping

在**不改变原来模型几何信息**情况下通过**扰动改变法线**，模拟得到凹凸不平的感觉

![[3d704b21b12a6c9be6497bd4fc5d000 1.jpg]]

![[Pasted image 20230610210537.png]]

![[Pasted image 20230610210556.png]]

##### 2. 位移贴图 Displacement Mapping

实际**改变**了三角形顶点的**位置**，更加逼真，但要求模型的三角形**足够细致**，跟得上纹理的变化频率，运算量更高

![[4c192df6457bd597863fd16588891a0.jpg|500]]

#### 3. 程序纹理

三维的纹理，并非生成真正的纹理图，而是定义三维空间中的**噪声函数**，再通过映射得到结果

#### 4. 预计算着色

对环境光进行预计算处理，再在原来的纹理上做一层**遮蔽**

#### 5. 三维渲染

记录三维的纹理信息，通过这些信息渲染

![[Pasted image 20230610212053.png]]