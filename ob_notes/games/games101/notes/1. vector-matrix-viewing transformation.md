![[Pasted image 20230606231906.png]]

# 一、向量

图形学中向量默认以**列向量**表示

坐标系采用**右手系**

## 叉乘运算（A × B）

a = (x1, y1, z1)；b = (x2, y2, z2)

![[Pasted image 20230608100227.png|200]]

* 方向：右手系从A到B，大拇指方向
* 大小：||A|| * ||B|| * sin<A, B>
* 用途：
	1. 判断一个向量在另一个向量左边（正）还是右边（负）
	2. 判断一个点在图形的内侧还是外侧：沿着一个方向绕图形，每条边的向量与起点到该点向量的**叉乘都是同号**，点就在内部

# 二、矩阵 及 点的变换

* **仿射变换 = 线性变换（如旋转/缩放/切变） + 平移变换**
* 仿射变换可以当作是在向量**左乘**一个变换矩阵
* 不同的变换顺序实际效果也不同（矩阵乘法中从**右往左**变换）

## 1. 二维

### 1. 齐次坐标 homogenous coordinates

增加一个维度来作平移变换（n维向量用**(n+1, 1)** 来表示）

![[d20a5c0adcc0bbd5284fccbefdbb1ca.jpg|400]]

二维的点的第三个值为1，向量的第三个值为0；

变换矩阵的**左上角矩阵**为原本的线性变换的矩阵，其右边相同行数的那一列用来平移变换，最后一整行前面全是0最后面一个1

![[1132cd7003c0cd357815d733a18a680.jpg|400]]

通过第三个值也可以推出下面的公式

其中点+点的第三个值为2，在齐次坐标下就相当于前面的值都/2，使得第三个值变成1（代表一个点 -> 原来的点的**中点**）

![[46bb97bfc10c78ab9d00ea61970111a.jpg|400]]

### 2. 二维的变换：缩放、旋转、移动

![[4235a7c8d4fa6a1446410b15f57ff30.jpg|400]]

旋转对应的矩阵 $R^{-1} = R^T$

![[5735b6c3dc24dbce54358039ef46414.jpg|400]]

## 2. 三维（与二维类似）

![[d555a2c4fb22056288032b56003d99b.jpg|400]]

![[838ac69e11f656f7af11e676aa1dd19 1.jpg|400]]

### 1. 三维的缩放与移动

![[c508f9f3a6f367f80fd774cd122569e.jpg|400]]

### 2. 三维的旋转

#### 1. 绕坐标轴旋转

![[2822ec2004017d3c3eed1a30f7eddfe.jpg|400]]

三维旋转：绕某个轴旋转（绕哪个轴旋转，其矩阵的对角线上对应的点的值为1，该点对应的行和列的其他值都为0）；绕哪个轴旋转，哪个轴对应的点坐标不变，相当于**映射**到另外两个轴对应的面来绕中心点旋转

1. 绕x轴相当于面在yz上从y到z旋转；
2. 绕z轴相当于面在xy上从x到y旋转；
3. 绕y轴相当于面在xz上从z到x旋转，与前两种相反，所以是逆旋转，也相当于正旋转的**转置**

#### 2. 绕任意轴n旋转α角度

![[457335a26d35b2c149e029216e6c456.jpg|500]]

推导：

![[016f05fe360f0bba8d56da296600c63.jpg|300]] ![[151012742785ac497cc43f49dab4dee.jpg|300]]

# 三、Viewing（观测） Transformation（MVP）

1. model transformation：模型变换（搭好场景——只是模型移动）
2. view transformation：视图变换（找好相机角度——相机和模型一起移动）
3. projection transformation：投影变换（将三维空间投影到二维空间）

## 1. View（视图）/Camera Transformation

![[61a013faee7657e7ef4b3cf2cc8d74f.jpg|400]]

将相机放到原点（0，0，0），往 -Z 方向看，向上方向为 Y（相机变换的时候物体也跟着做相同的变换——相对运动）

1. 将相机所在**位置position(e)平移**到原点（T-view）
2. 将**gaze direction(看的方向g)旋转**到 -Z轴；将**up direction(相机上面的面的方向t)旋转**到 Y轴；之后另一个方向(g×t)就指向x轴方向（R-view）
	* 直接将g移到-z、t移到y，(g x t)移到x不好做，可以反过来：x（1，0，0）移到（g x t），y（0，1，0）移到t，z移到-g得到$R^{-1}_{review}$（带入x、y、z轴三个点来用矩阵左乘都可以得到旋转后的点），然后由于旋转矩阵的逆就是他的转置（正交矩阵），所以可以直接得到 $R_{review} = (R^{-1}_{review})^T$
3. 最终得到相机变换到原点的**左乘**矩阵 **M-view = R-view * T-view**

![[06d78f550f1e72661cfbfa9801d79a9.jpg|400]]

## 2. Projection Transformation

### 1）Orthographic Projection 正交投影

1. 将相机（点）放在坐标轴中心点，往 -Z轴 方向看，顶部朝 Y轴
2. 扔掉物体的z轴
3. 将物体缩放到矩形 \[ -1, 1 ]中

![[f4416613b11baa6fccaf9a98fa66274.jpg|400]]

1. 将长方体中心放到坐标轴中心（移动Translation）
2. 缩放成边长为2的立方体（缩放Scale）

![[927a5ad06bd7dbb4684ebd88be04f13.jpg|500]] ![[Pasted image 20230709105341.png|400]]

### 2）Perspective Projection 透视投影 ^pp-23-7-14

![[53f8e6f79e548dfe4fa9bb6f999880f.jpg|400]]

1. 先将视角的棱锥体**压缩成长方体**
	1. 近平面（z=n的平面）的点不变（经过透视投影后）
	2. 远平面（z=f 的平面）的 z值 不变，且中心点不变
2. 再对长方体进行**正交投影**

下图中最左边的点为相机位置，中间竖线代表的是近平面n（距离相机距离为n），最右边的竖线代表的是远平面f（距离相机距离为z）

![[5b7531701e1b3d831de431b60402e1e.jpg|400]]

1. 根据**相似三角形**得到**xy坐标**的值（远平面的点投影到近平面)
2. 根据**近平面的点不变**得到矩阵的三行的前两个值
3. 根据**远平面的中心点（0, 0, f, 1）不变**得到矩阵剩下的未知值

![[e8b9252798ab8c3d17afb804a9b1408.jpg|300]]  ![[a5561890e304121da99d59a4abbd985.jpg|300]]

* M-persp = M-ortho · M-persp->ortho
* 自此，运用M-persp矩阵左乘物体每个位置的坐标就可以得到**投影得到的坐标（x，y，z）**，可用在后面的光栅化处理
* 注意：在推算 $M_{perspect}$ 的时候对生成的点坐标值乘了 z，所以对于原坐标 (x, y, z)的点，经过透视投影 $M_{perspect}\cdot z$ 了之后得到的坐标 **$z'$ 需要除以z**才能得到真实的坐标（“除以z”的操作，决定了整个透视投影是**非线性的**）