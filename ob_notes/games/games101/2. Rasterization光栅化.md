> 光栅化是将几何图元变为二维图像的过程，包括决定哪些格子被占用以及为被占用的格子分配颜色

# 一、Triangle

![[fd3780b158ac538a9ef434090530071.jpg|500]]

* **field-of-view（fovY）** ：y轴可视角度
* **aspect ratio** ：宽高比

![[Pasted image 20230608214606.png|400]]

将立方体从\[ -1, 1 ]^2 移动到屏幕的 \[ 0, width ] * \[ 0, height ] 位置处

![[85a8873d290cc1de78b67cc8ee6ecb6.jpg|500]]

## 采样

> 采样：将所有到达光学原件的感光平面的光学信息，离散成**像素点**的过程

投影到屏幕上的图形都可以用**三角形**组成，通过采样三角形覆盖的点来赋予不同的颜色

![[Pasted image 20230608220643.png|400]]

判断像素中心是否在三角形内：沿着三角形的**一个方向**，用三角形边的向量**叉乘**该边的起点指向像素中心的向量，如果三条边的叉乘结果都是**同号**，表示在三角形内

# 二、Antialiasing and Z-Buffering（反走样和深度缓冲）

>走样：对于不同频率的信号，以相同频率的采样方式会得到相同的结果

## 1. Sampling Artifacts（采样的瑕疵/痕迹）

1. jaggies（锯齿）—— 空间上的采样
2. Moire（摩尔纹）—— 图片的欠采样
3. Wagon wheel effect（车轮效应）—— 时间上的采样

* 原因：信号变化的速度太快，采样速度慢（对与高频需要更高的采样频率，否则得到的图像会出现artifacts）

![[dbd91398044b98376df28ea00b1b302.jpg|400]]

采样频率不足可能导致两种不同的信号得到相同的结果

![[daf75df4ebd702b5e11ac810fb90f14.jpg|500]]

## 2. Filtering 滤波

先对信号做模糊处理（低通滤波），再采样

* 图像的低频：像素变化不明显的部分 -> 得到模糊图像 
* 高频：像素变化剧烈的部分 -> 得到图像的边缘部分

![[cf72abd2a0a942aed01216dc4422bb3.jpg]]

卷积 => 滤波

图像中**时域的卷积**（将图像模糊）相当于**频域的乘积**（将图像和卷积核经过傅里叶变换相乘 -> 保留低频部分）

卷积核越大，得到的图像越模糊，频率信号中的高频越少（只能留下低频部分），得到频域图像内容越小

## 3. Anti-aliasing 反走样

采样就是在**重复原始信号的频谱**；采样的频率越小，重复的信号就贴的越紧，导致出现**重合**现象，就是走样原因（当采样足够多接近完整图像的时候，频率图就相当于只有一个原本的频率信号；随着采样点的减少，原本频域的部分重复数目逐渐增多，最终会导致**重叠**）

![[253efe7d4a3be62f2c9b8d8576a0c52.jpg|600]]

### 1）方法：

1. 增大**采样率**（可行性不高）
2. 先做**模糊**再做采样：通过将频率图中原本的频率的高频部分滤掉，使得重复的时候不容易出现重叠

![[8ba8652ec0c5d0628d6e68711e21655.jpg|600]]

### 2）模糊处理

1. **MSAA**：对每个像素（一个格子）里面再分成多个小格子，计算大格子内部**小格子的覆盖率**（并没有提高分辨率，每个大格子还是一个像素）
2. **FXAA**（Fast Approximate AA）：先采样得到图像，再将锯齿部分替换掉
3. **TAA**（Temporal AA）：运用之前的像素值

MSAA：

![[Pasted image 20230608220739.png|200]] ![[Pasted image 20230608220750.png|200]] ![[Pasted image 20230608220800.png|200]]

![[ab0de79a03071436778ab974c6bf289.jpg|500]]


## 4. Z-buffering 深度缓冲

### 1. 画家算法

先画远处的物体再画近处的物体，近处的物体会覆盖远处的物体

但是画家算法无法很好解决下图问题（因为画家算法需要得到的是**整个**物体的远近程度）

![[6497734107ea37ceeab6b35ee8a72a6.jpg|400]]

### 2. Z-Buffer

在生成一张图片的同时，同时生成一张**像素点**的**深度信息**的图片（越近越黑）；要生成一张记录深度信息的图片，可以通过判断所有物体的对应**三角形的像素点远近**来确定是否更新当前像素点的颜色及深度

![[f4fc5c17cefecf90555c40bab995d17.jpg|500]]

像素点距离近的会覆盖距离远的

![[58815331a9e4e820e575230593cc59e.jpg|500]]